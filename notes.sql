/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 8.0.23 : Database - notes
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`notes` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `notes`;

/*Table structure for table `admin` */

DROP TABLE IF EXISTS `admin`;

CREATE TABLE `admin` (
  `admin_id` int NOT NULL AUTO_INCREMENT COMMENT '管理员唯一标识',
  `admin_name` varchar(60) NOT NULL COMMENT '管理员昵称',
  `password` varchar(60) NOT NULL COMMENT '管理员登录密码',
  PRIMARY KEY (`admin_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `admin` */

insert  into `admin`(`admin_id`,`admin_name`,`password`) values (1,'admin01','1201'),(2,'admin02','1202'),(3,'admin03','1203'),(4,'admin04','1204'),(5,'admin05','1205'),(6,'admin06','1206');

/*Table structure for table `announce` */

DROP TABLE IF EXISTS `announce`;

CREATE TABLE `announce` (
  `announce_id` int NOT NULL AUTO_INCREMENT COMMENT '公告id',
  `announce_title` text NOT NULL COMMENT '公告标题',
  `announce_content` text NOT NULL COMMENT '公告内容',
  `create_time` datetime NOT NULL COMMENT '发布公告的时间',
  PRIMARY KEY (`announce_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

/*Data for the table `announce` */

insert  into `announce`(`announce_id`,`announce_title`,`announce_content`,`create_time`) values (5,'版本更新','语鹊笔记管理系统更新至2.0版本','2021-04-15 20:21:59');

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `comment_id` int NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `note_title` varchar(60) NOT NULL COMMENT '所属的笔记标题',
  `user_name` varchar(60) NOT NULL COMMENT '给予评论的用户名',
  `comment_content` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论的内容',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

/*Data for the table `comment` */

/*Table structure for table `note` */

DROP TABLE IF EXISTS `note`;

CREATE TABLE `note` (
  `note_id` int NOT NULL AUTO_INCREMENT COMMENT '笔记的唯一标识',
  `note_title` varchar(100) NOT NULL COMMENT '笔记标题',
  `author_id` int unsigned NOT NULL COMMENT '笔记发布者id',
  `note_content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '笔记内容',
  `create_time` datetime NOT NULL COMMENT '笔记发布时间',
  `overt` tinyint(1) NOT NULL COMMENT '笔记是否公开',
  PRIMARY KEY (`note_id`),
  UNIQUE KEY `idx_unique_title` (`note_title`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=82 DEFAULT CHARSET=utf8;

/*Data for the table `note` */

insert  into `note`(`note_id`,`note_title`,`author_id`,`note_content`,`create_time`,`overt`) values (40,'霸气—必修一',28,'霸气的基本使用方法  —— 雷利','2021-04-15 19:21:07',1),(41,'霸气—必修二',28,'见闻色预测未来的方法 —— 卡二','2021-04-15 19:21:51',1),(42,'霸气—选修一',28,'武装色流樱的使用方法 —— 豹大叔','2021-04-15 19:23:02',1),(43,'霸气—选修二',28,'霸王色霸气缠绕的使用方法 —— 凯多','2021-04-15 19:23:39',1),(44,'一刀流',29,'狮子歌歌1','2021-04-15 19:39:55',1),(45,'二刀流',29,'罗生门','2021-04-15 19:27:59',1),(46,'三刀流',29,'三千世界','2021-04-15 19:28:12',1),(49,'三刀流\\',29,'百八烦恼风','2021-04-15 19:31:40',1),(50,'三刀流奥义',29,'阿修罗魔九闪','2021-04-15 19:32:08',1),(51,'卡莎',31,'虚空索敌+猎手本能+艾克希亚暴雨','2021-04-15 19:38:34',1),(52,'小炮',31,'火箭跳跃','2021-04-15 19:39:36',1),(53,'三分球',32,'onemotion单动投篮','2021-04-15 19:42:50',1),(54,'传球',32,'不看人背传','2021-04-15 19:43:19',1),(55,'控球',32,'双手控球+背运','2021-04-15 19:47:15',1),(56,'Java',33,'Scanner\nfinal类    \nnext实例方法：public String next() \n//获取用户键盘输入\n//hasNextLine()；是否有下一行\n//nextLine();读取下一行\nnextXxx();接收特定类型的数据，否则系统抛出异常（报错）','2021-04-15 19:49:54',1),(57,'字符串',33,'String字符串功能：\n字符串变量.length()\n字符串变量.charAt(索引位置)       返回指定索引处的值\n字符串变量.contains(\"\")              判断是否包含某个字符串/字符(单)\n字符串变量.indexOf(\"\")               在此对象表示的字符序列中第一次出现该字符串的索引，如果未出现该字                                                             符，则返回-1\n字符串变量.lastindexOf(\"\")          从后往前查找，但索引数是从前往后数\n字符串变量.startwith(\"\")              判断是否以某个字符串开始，boolean\n字符串变量.endwith(\"\")               判断是否以某个字符串结束 \n☆字符串变量.split(\"\")                  以\"字符串中的某个字符\"将字符串分隔开成一个字符串数组\n字符串变量.trim(\"\")                     去掉前后的空字符（去两头，中间不行）\n字符串变量.replace(\"要替换的\",\"替换内容\")                返回值为String，替换字符串\n字符串变量.replaceAll(\"\",\"\")         replace与replaceAll基本一样，但replaceAll支持正则表达式替换\n字符串变量.substring(2)              从字符的第二个索引位置开始截取字符串；字符串变量.substring(2,6)包前不                                                   包后[从第一个索引参数（包含）一直截取到第二个索引参数截止（不包后）]\n字符串变量.subSequence( , )  \n字符串变量.toLowerCase()           小写\n字符串变量.toUpperCase()           大写\nStringBuilder，StringBuffer字符串','2021-04-15 19:50:18',1),(58,'面向对象',33,'a.封装\n类的设计：要把该隐藏的部分隐藏起来；要把用户操作接口暴露出来——封装（哲学：合理隐藏，合理暴露）\n一般情况：成员变量应该隐藏（有些常量也会暴露）；方法应该暴露（有些特殊工具方法也会隐藏） //成员变量都应该私有化\n一般对成员变量进行隐藏，但会提供一套getter和setter方法来操作成员变量使其合理暴露\nJava是停供了3个修饰符（4个权限）来控制隐藏和暴露（封装）\n①private(本类访问权限)：它修饰的方法、成员变量只能在该类中被访问（私家车）——子类不能访问//私有的成员变量，只能在本类中直接访问，其他任何地方都不能直接访问     彻底的隐藏\n②缺省(包访问权限)：它修饰的方法、成员变量只能在该类、该类所在同一个包中被访问。部分隐藏、\"包\"访问权限\n③protected(包访问权限+子类访问权限)：它修饰的方法、成员变量可以在该类、该类所在同一个包、该类子类中被访问。部分暴露，子类访问权限（子类不一定在同一个包下）\n④public(公开权限)：它修饰的方法、成员变量可以任意地方被访问。彻底暴露、公开权限（公交车）//什么地方都可以访问\nprivate                 缺省               protected                public\n当前类                    √                      √                        √                         √ \n同一个包                 x                      √                         √                         √  \n当前类的子类          x                       x                         √                          √\n任意地方                 x                       x                         x                          √\n总结：public>缺省>protected>private\nprivate:\nadj.私有的;私用的;自用的;为一部分人的;私人的;秘密的;内心的;隐秘的;私下的\nn.二等兵，列兵(级别最低的士兵）\n格式;    private 类型 成员变量名称；\n     set成员变量名称（首字母大写）\nget成员变量名称（首字母大写）\n☆合理暴露：通过方法对私有的成员变量进行合理的暴露（安全）\n为什么还是要暴露？因为还是要被别人访问，但又不想被别人直接访问，因为太不安全了。所以要进行 合理的暴露，但☆得有要求才能访问。暴露就是为这个成员变量注入值（setAge—规范），用get变量方法间接访问','2021-04-15 19:50:58',1),(59,'抽象类',33,'abstract关键字：\nabstract可以用于修饰类和方法：\nabstract修饰的类称为抽象类，abstract修饰的方法称为抽象方法\n抽象类：用abstract修饰\n☆有得有失：得到了拥有抽象方法的能力，失去了创建对象的能力（但是有构造器-没意义）\n说服力：反证法——对象.抽象方法();在本类中没有方法体怎么执行？可推——>所有抽象类不能创建对象\n在父类中的有些方法：在子类中必须要把该方法重写，那么父类方法的方法体就没必要写（没有意义）——诞生了抽象方法：public abstract void run();\n1.要被abstract修饰    2.只有方法签名，没有方法体（方便）  3.可以约束子类必须有个跑的方法 \n4.一个类有抽象方法要被定义成抽象类加上abstract[抽象类就是个模板]\n5.在父类中定义了很多方法，此时不知道怎么写（父类不知道子类跑步跑的快还是慢/唱歌唱的好不好听）只知道要约束子类有这种方法，具体的实践交给子类\n6.当一个类继承了抽象类，必须重写所有的抽象方法，否则就变成了抽象类\n7.抽象类存在的意义就是为了被子类继承\n8.抽象类可以没有抽象方法\n抽象方法：\n1.要被abstract修饰\n2.只有方法签名，没有方法体就是抽象方法\n3.抽象方法存在的意义就是必须被子类重写\n注意：当一个类继承了抽象类，这个类必须重写抽象类的所有抽象方法，否则也必须定义成抽象类\n    只要有一个抽象方法没有被重写，子类也必须称为抽象类 ——（不能定义成一个具体的类——因为这样可以创建对象）——所以抽象方法是可以被继承的\n          一个类如果拥有了抽象方法，这个类必须定义成抽象类\n    子类在创建对象时会调用父类的构造器，调用方法时用的是子类重写的方法\n抽象类作用：\n①定义抽象方法\n②派生子类，被继承\n③定义成员变量，方法等（也可以有其他的普通方法）\n④调用static修饰的成员（也是个类，可以调用静态成员变量和静态方法）\n⑤设计模板模式\n抽象类可以实现一个设计模式：抽象类可以充当子类的模板——相同的代码抽出来作为模板\n（模板没有自己的对象——抽象的）\n模板模式：在很多时候，程序中存在一些相同的格式模板代码\n   在程序中计算一个算法的过程中，我能确定该算法的大部分内容，但还有其中某个部分不能确定，于是我就将暂时不能确定的部分定义成一个抽象方法。这样一来，就可以把算法写出来，把该算法中暂时不能确定的地方交给抽象方法——这个抽象就是模板，这种设计模式就叫模板模式\n例如;作文模板','2021-04-15 19:51:27',1),(60,'接口',33,'接口是一种更彻底的抽象，接口只能包含抽象方法,不能包含普通方法\n接口的意义：接口体现出一种供大家都来遵守的规范\n而规范应该是公开的，以便其他人来遵守该规范，因此接口里的成员都应该是public的权限【接口就是规范】\n定义接口的语法：\n//UI：User Interface ：用户接口（与用户打交道的接口——界面设计）\n[修饰符] interface 接口名 extends 父接口,父接口                //根本就没有class\n{\n//public static final 修饰的成员变量[可以有常量，后面用类名调用]——也可以省略，自动帮助加上\n//public abstract 方法 —— 接口中的抽象方法可以无需加上public abstract修饰，因为会自动加上(默认加上因为接口中只能有公开抽象方法)\n//内部类（接口，枚举属于内部类成分）接口里再定义接口\nJDK1.8之后接口不再纯洁：不再是只有抽象方法了\n//public static 类方法/[返回值类型 方法名]，必须有方法体（静态方法）\n//public default 实例方法，必须有方法体\n}\n注意：Java的类是单继承的，但是接口是多继承（父接口）的，接口的多继承弥补了Java单继承(\"不够灵活:不能一下子直接继承好几个父类\")的不足\n☆为什么Java只能是单继承，而接口可以多继承？\n不能同时覆盖掉A和B\n规范重叠的话—合并到一起覆盖掉—重写的话还是一个（没有方法体根本就不会自己执行，交给子类重写的）\n如果没有重叠——所有规范都要遵循\n接口的特殊：\n没有main方法\n实例变量默认会自动帮助加上public static final 变成常量（以为是实例变量其实是常量）——接口不是用来创建对象的，所以不能有实例变量（接口连构造器都没有）\n注意：常量一定要有初始值\nInterface：n.(人机)界面(尤指屏幕布局和菜单);接口;接口程序;连接电路;(两学科、体系等的)接合点，边缘区域\n    v.(使通过界面或接口)接合，连接\n接口存在的意义就是为了(被子类)实现\n接口的使用：\n接口不能创建对象：没有构造器，如果有对象，当调用抽象方法时，方法不能跑起来(没有方法体)——没意义\n实现接口的格式：多实现\n[修饰符] class <类名> extends 父类 implements 接口,接口,接口...{\n}\n注意：Java类是单继承，但接口可以多实现。接口可以多继承多个接口，但是接口不能继承多个类(因为这样会继承了父类的实例成员变量和实例方法X)\n小米类每new一个类，相当于买了一个小米电插座，都可以调用重写的实例方法(2孔，3孔)\n用户使用规范——想换的话只需要改变一个地方，其他东西不用改(面向接口编程)——多态\n    接口的实现相当于类的继承，一个类如果实现了接口，这个类必须重写所有接口的所有抽象方法，否则这个类变成抽象类     \n面向接口(规范)编程：应用在用户切换上，而项目代码就不需要做大的改动(只需要改一个地方)\n行业制定规范(接口)，插座厂商(公牛,小米)实现规范,用户使用规范（两座还是三座）\n抽象类一般用于模板内,接口有很多方法（功能）制定一个规范（可能要扩展或修改）以便随意切换\n抽象类和接口的区别？\n相同点：\n1. 都可以拥有抽象方法\n2. 都不能创建属于自己的对象\n3. 都是为了派生子类(抽象类是为了被继承，接口是为了被实现)\n4. 都可以定义常量\n不同点：\n1. 抽象类除了抽象方法还可以拥有构造器和实例成员\n2. 抽象类是单继承的，接口是多继承多实现的（一个接口可以继承很多个接口，一个类可以实现很多个接口）\n抽象类可以创建对象吗？不可以，如果能创建对象就可以调用它的抽象方法，而抽象方法是不可以执行的(没有方法体)所以就不能创建对象\n抽象类可以有构造器吗？可以私有吗? 可以有构造器，而且必须有构造器。抽象类的存在就是为了被继承，如果没有构造器，子类就无法创建对象（因为子类创建对象时都会先调用父类的构造器），子类创建对象的时候一定会先调用父类的构造器一次，所以抽象类一定要有构造器。可以私有（编译时不报错）但抽象类的构造器私有没意义，抽象类的存在就是为了派生子类，一私有，子类就懵了，因为子类要创建对象要调用父类构造器(此时调不了，没有权限！——被绝育了不能派生子类——报错)\nabstract和final的关系\n在修饰方法和类的时候都是互斥的，不能同时出现：abstract修饰类让这个类变成模板被继承，final修饰类不能被继承，abstract修饰方法——抽象方法——被重写，final修饰方法——方法不能被重写\n特殊：实现了接口，调用构造器时super();不报错\n          但是接口里有构造器就报错——special','2021-04-15 19:51:46',1),(61,'内部类',33,'类的第五大成分：修饰外部类：public（主类:主类类名与java文件名相同）| 缺省（次类）组合[ abstract（抽象类）| final（不能被继承）]\n1. 成员变量\n2. 构造器\n3. 代码块\n4. 方法\n5. 内部类：修饰符——缺省 | public | private | protected 组合 [static，final | abstract]\n概念：类中的类\n理论：Java所有的代码、程序都是以类的形式存在的\n编译时产生两个字节码文件，内部类编译以后的形式：外部类$内部类.class\nstatic区分[最关键——区别于是属于类还是属于对象]：静态内部类，实例内部类\n1.静态内部类：\n①被static修饰的内部类\n②静态内部类：与外部类一起加载，只会加载一次\n③内部类的实例变量可以与外部类的实例变量相同\n   内部类也是类——可以定义内部类实例成员变量和静态变量和五大成分（静态代码块）\n   内部类的对象创建可以在外部类中，当每次一执行内部类的时候都会触发内部类的静态块（比如创建内部类的对象）Inner.inner = new Inner(); <=> Nature.Inner.inner = new Nature.Inner(); //直接用外部类.内部类\n④静态变量，静态代码块；静态内部类可以定义静态方法（一个）\n很好理解：访问内部类中的name\n相当于this.name\n可以访问外部类的静态成员\n创建一个内部类对象，调用内部类的test()方法：先找自己内部类（Inner）里的num（默认加this），找不到再找外部类的num（变量的就近原则）\nTips：1.因为静态内部类属于外部类的静态成员，静态成员可以直接. 在一个类中访问静态东西时主调类名可以省略 \n   2.静态内部类可以访问外部类的静态成员，但绝对不可以访问外部类的实例成员，外部类的实例成员只能用外部类的对象来访问（在内存中没有关系，连外部类都不能访问外部类的实例成员）\n2.实例内部类：\n①属于外部类对象的（在外部类对象里），并不是所属于外部类的类\n②无static修饰的内部类\n☆③实例内部类不能定义静态方法和静态成员变量，因为实例内部类属于外部类对象的，并不是属于外部类的类但静态内部类可以定义静态方法（只有一个）那么静态成员就会有很多个（与java设计理念冲突）\n实例内部类可以创建出好多份，而静态的东西只要一份——与之冲突（所以定义静态的东西放在实例内部类以外）\n④实例内部类中的实例方法中访问外部类实例(对象)成员变量的时候，应该加上外部类的类名.this\n⑤实例内部类可以访问外部类的静态成员(因为静态成员只有一个——按图索骥地找到)\n⑥实例内部类可以访问外部类的实例成员（分布在每个对象里）\n   一开始this.name先访问实例内部类的对象的name，可是找不到，就找实例内部类所属实例（对象）的name：顺着线找到宿主中有name【就近原则】\n   \n☆⑦实例内部类中的实例方法中可以通过：外部类类名.this.外部类对象 访问外部类的实例（对象）成员信息【内部类也相同有的情况下】\n⑧可以定义常量：static final     ：private static final int age = 10;(√)    \n不可以定义静态成员变量：private static int age = 10;(X)\n它不知道是new的是哪个实例内部类，必须指明是哪个宿主的实例内部类 \n而静态外部类或静态内部类不需要这样子，因为只有一个\nX\n内部类的作用：\n提供更加安全的访问机制，内部类因为属于一个外部类，所以访问权限更多(private 内部类名)\n内部类的继承：\n1.继承静态内部类：extends 外部类.内部类（公开化才能继承）\n子类构造器在第一行一定有一个隐式的super();调用——找父类的构造器——父类必须要有无参数构造器\n☆2.继承实例内部类：实例内部类一定需要外部类的对象作为宿主，不能直接去调用外部类的实例内部类的构造                                       器\n    所以一定要先为继承的实例内部类提供一个宿主——外部类对象（可能有多个）【所以得告诉它请在这个对象下的实例内部类里new 对象】\n    extends 外部类.内部类\n    宿主.new 实例内部类\n抽象类能跑（执行），但不能创建对象，因为抽象类是用来被继承的。\n接口能跑：jdk1.8后支持静态方法——能跑——接口既可以当接口用，又可以当普通类用（功能更强）\n抽象类有抽象方法和实例方法，但是不能new对象（创建对象）\n实现类（重写抽象方法）：实现接口的类才可以成为实现类\n☆匿名内部类（重点）：\nnew 接口/抽象类{        ——> 相当于一个匿名内部类对象\n//必须重写所有的抽象方法，否则报错\n}\n返回一个匿名内部类的对象，类型就是接口/抽象类\n缺点：匿名抽象类只能使用一次（用完了还需要的话再new一个）\n接口：\n       抽象类：\n原理：抽象类不能创建对象（抽象方法），但依然要坚强地去new 一个对象——>那就在匿名内部类里重写抽象方法','2021-04-15 19:52:22',1),(62,'MySQL',33,'5.创建表：create table 表名（\n列名  列类型，                               //字段\n列名  列类型   ）；                        //最后一个不用加逗号\n建表跟建类是一样的，分析打算在这个表里存哪些数据，然后去固定格式\n例如：存储学院信息：姓名 性别 学号 年龄 \nsql里没有字符串类型，都叫字符型，多少个字符都叫字符型\nvarchar——可变的字符\n只有一条命令结尾时，才能用分号','2021-04-15 19:53:36',1),(63,'数据库',34,'SQL语法规范：\n1.不区分大小写，但关键字（库名，表名，字段名）建议大写，其他关键字建议小写（列名小写）\n2.每条命令最好用分号结尾；\n3.每条命令根据需要，可以进行缩进或换行\n4.注释\n单行注释：#注释文字\n单行注释：-- 注释文字\n多行注释：/*注释文字*/\n5.可以用空格和缩进来增强语句的可读性','2021-04-15 19:58:19',1),(64,'sql1',34,'分类：\n①、DDL：数据定义语言，用来定义数据库对象：库、表、列等（创建时用）\ncreate drop alter\n②、DML：数据操作语言，用来定义数据库记录（数据）\n表里数据的增删改：insert update delete\n③、DCL：数据控制语言，用来定义访问权限和安全级别\n④、DQL：数据查询语言，用来查询记录（数据）\nselect','2021-04-15 19:58:37',1),(65,'sql2',35,'一、查询常量：\nSELECT 100或SELECT 100 FROM employees;\n二、查询表达式;\nSELECT 100%3;   //可以把结果读取到服务器端，然后在页面上显示。不用写来自于某个表了，因为这里边不涉及表中的字段\n三、查询单个字段：\nSELECT last_name FROM `employees`;    //直接双击，着重号，本身不是关键字加不加无所谓\n四、查询多个字段：\nSELECT `last_name`,`email`, `employee_id` FROM employees;\n五、查询所有字段：\nSELECT * FROM `employees`;   //*代表所有，类似于Java\n/*快捷键F12可以快速对齐格式（换行）*/\n六、查询函数（调用函数，获取返回值）：\nSELECT DATABASE();\nSELECT VERSION();\nSELECT USER();\n七、起别名：\n方式一：使用as关键字\nSELECT USER() AS 用户名;\nSELECT USER() AS \'用户名\';\nSELECT USER() AS \"用户名\";\n引号作用：\nSELECT last_name AS 姓 名 FROM employees；//报错\nSELECT last_name AS \'姓 名\' FROM employees；//单引或双引\n方拾二：使用空格\nSELECT USER()  用户名;\nSELECT USER()  \'用户名\';\nSELECT USER()  \"用户名\";\nSELECT last_name  \'姓 名\' FROM employees；','2021-04-15 19:59:46',1),(66,'sql3',36,'七、起别名：\n方式一：使用as关键字\nSELECT USER() AS 用户名;\nSELECT USER() AS \'用户名\';\nSELECT USER() AS \"用户名\";\n引号作用：\nSELECT last_name AS 姓 名 FROM employees；//报错\nSELECT last_name AS \'姓 名\' FROM employees；//单引或双引\n方拾二：使用空格\nSELECT USER()  用户名;\nSELECT USER()  \'用户名\';\nSELECT USER()  \"用户名\";\nSELECT last_name  \'姓 名\' FROM employees；','2021-04-15 20:00:48',1),(67,'sql4',37,'十、查看表的结构\nDESC employees;        //字段、字段的类型、约束\nSHOW COLUMNS employees;      //查看列\n基础查询案例讲解：\nSELECT last_name,job_id,salary AS sal\nFROM employees;                                           (√)\nSELECT * FROM employees；                         （√） \nSELECT employees_id,last_name,\nsalary * 12 \"ANNUAL SALARY\"\nFROM employees;                                            (√)\n显示表departments的结构，并查询其中的全部数据\nDESC departments；\nSHOW COLUMNS FROM departments；\nSELECT * FROM departments；                         // 前提是用的数据库是myemployees\n显示出表中employees中的全部job_id(不能重复)\nSELECT DISTINCT job_id FROM employees;       //F9执行\n显示出表employees的全部列，各个列之间用逗号隔开，列头显示成OUT_PUT     //做拼接\nSELECT CONCAT(employees,\',\',first_name,\',\',salary,\',\',commission_pct) AS \"OUT_PUT\"\nFROM employees;\n做拼接的时候，其中一个参数为null那么结果为null——>解决办法：把null当做空字符\n借助ifnull函数：判读该字段是否为null，如果是...，不是...\nSELECT commission_pct,IFNULL(commission_pct,\'空\') FROM employees;\n 可能为null的字段或表达式，如果为null就显示空，不为null就显示本身的值\n格式：ifnull(表达式1，表达式2)\n/*\n表达式1：可能为null的字段或表达式\n表达式2：如果表达式1为null，则最终结果显示的值\n功能：如果表达式1为null，则显示表达式2，否则显示表达式1\n*/\n可视化图形：Navicat使用快捷键：https://www.bilibili.com/video/BV1yA41147Vi?from=search&seid=4816380891295077920\n新版连接查询少了内容','2021-04-15 20:02:08',1),(68,'sql5',38,'语法：\nSELECT 查询列表\nFROM 表名\nwhere 筛选条件；         //结果是true或false，当...条件成立时类似于if\n*/\n执行顺序：\n①from子句\n②where子句\n③select子句\n特点：\n1、按关系表达式筛选：>   <    >=     <=    =(就一个)    <>/!=(不等于) 也可以使用!=，但不建议\n2、按逻辑表达式筛选：逻辑运算符：&&  ||  !  /  and or not \n3、模糊查询：like \n   in\n         between and \n         is null (判断空的)\n一、按关系表达式筛选：\n查询部门编号不是100的员工信息\nSELECT  *                    //员工信息(说的不具体，用*)\nFROM employees        //表名（员工表）\nWHERE  department_id  <> 100;                    //部门编号不是100\n查询工资<15000的姓名、工资\nSELECT last_name,salary\nFROM employees\nWHERE salary<15000;','2021-04-15 20:02:45',1),(69,'sql6',39,'二、按逻辑表达式筛选\n查询部门编号不是50-100之间的员工姓名、部门编号、邮箱\nSELECT last_name,departments_id,email\nFROM employees\nWHERE NOT(departments_id>=50 and departments <=100);\n查询奖金率>0.03或者员工编号在60-110之间的员工信息\nSELECT *\nFROM employees\nWHERE commission_pet>0.03 OR (employees_id >=60 AND employees_id <=110);\n优质的SQL语句:可读性强，标准','2021-04-15 20:03:23',1),(70,'sql7',40,'三、模糊查询\n①like子句(like像...样子)    not like\n功能：一般和通配符搭配使用，对字符型数据进行部分匹配查询\n常见的通配符：\n_任意单个字符\n%任意多个字符：支持0-多个\n查询姓名(last_name)中包含字符a的员工信息\nSELECT *\nFROM employees\nWHERE last_name LIKE \'%a%\';\n查询姓名(last_name)中最后一个字符为a的员工信息\nSELECT *\nFROM employees\nWHERE last_name LIKE \'%a\';\n查询姓名(last_name)中第一个字符为e的员工信息\nSELECT *\nFROM employees\nWHERE last_name LIKE \'e%\';\n查询姓名(last_name)中第三个字符为x的员工信息\nSELECT *\nFROM employees\nWHERE last_name LIKE \'__x%\';                                 //不区分大小写\n查询姓名(last_name)中第二个字符为_的员工信息\nSELECT *\nFROM employees\nWHERE last_name LIKE \'__x%\';                             //全部都查出来了（X）\nWHERE last_name LIKE \'_\\_x%\';                            //  \\转义字符\nWHERE last_name LIKE \'_$_x%\' ESCAPE \'$\';          //设置$为转义字符\n②in（在...里面）\n功能：查询某字段的值是否属于指定的列表之内\na in(常量值1,常量值2,常量值3,...)\na not in(常量值1,常量值2,常量值3,...)    \n查询部门编号是30/50/90的员工名、部门编号\nSELECT last_name,department_id\nFROM employees\nWHERE department_id IN(30,50,90);','2021-04-15 20:06:54',1),(71,'sql8',41,'方法二：\nSELECT *\nFROM employees\nWHERE NOT (job_id=\'SH_CLERK\'\nOR job_id=\'IT_PROG\' );\n③between and\n功能：判断某个字段的值是否介于xx之间（用于判断区间值）\nbetween and/not between and\n查询部门编号是30-90之间的部门编号、员工姓名\nSELECT department_id,last_name\nFROM employees\nWHERE department_id BWTWEEN 30 AND 90;           //不能颠倒\nSELECT department_id,last_name\nFROM employees\nWHERE department_id >=30 AND department_id <=90;   \n查询年薪不是100000-200000之间的员工姓名、工资、年薪\nSELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE salary*12*(1+IFNULL(commission_pct,0)<100000 OR salary*12*(1+IFNULL(commission_pct,0)>200000;\nSELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE salary*12*(1+IFNULL(commission_pct,0) NOT BETWEEN 100000 AND 200000;\nis null/is not null\n查询没有奖金的员工信息\nSELECT *\nFROM employees\nWHERE commission_pct = NULL;     //(X) = 只能判断普通的数值\nSELECT *\nFROM employees\nWHERE commission_pct IS NULL;\nSELECT *\nFROM employees\nWHERE commission_pct IS NOT NULL;','2021-04-15 20:07:49',1),(72,'sql9',42,'方法二：\nSELECT *\nFROM employees\nWHERE NOT (job_id=\'SH_CLERK\'\nOR job_id=\'IT_PROG\' );\n③between and\n功能：判断某个字段的值是否介于xx之间（用于判断区间值）\nbetween and/not between and\n查询部门编号是30-90之间的部门编号、员工姓名\nSELECT department_id,last_name\nFROM employees\nWHERE department_id BWTWEEN 30 AND 90;           //不能颠倒\nSELECT department_id,last_name\nFROM employees\nWHERE department_id >=30 AND department_id <=90;   \n查询年薪不是100000-200000之间的员工姓名、工资、年薪\nSELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE salary*12*(1+IFNULL(commission_pct,0)<100000 OR salary*12*(1+IFNULL(commission_pct,0)>200000;\nSELECT last_name,salary,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE salary*12*(1+IFNULL(commission_pct,0) NOT BETWEEN 100000 AND 200000;\nis null/is not null\n查询没有奖金的员工信息\nSELECT *\nFROM employees\nWHERE commission_pct = NULL;     //(X) = 只能判断普通的数值\nSELECT *\nFROM employees\nWHERE commission_pct IS NULL;\nSELECT *\nFROM employees\nWHERE commission_pct IS NOT NULL;','2021-04-15 20:08:33',1),(73,'sql10',43,'语法：\nSELECT 查询列表\nFROM 表名\n[WHERE 筛选条件]                  //可以省略\nORDER BY 排序列表                //可以多个\n执行顺序：\n①from 子句\n②where 子句\n③select 子句\n④order by 子句\n       SELECT last_name,salary\n       FROM employees\n       WHERE salary>10000\n       order by salary;','2021-04-15 20:09:39',1),(74,'sql11',44,'djy11','2021-04-15 20:10:30',1),(75,'sql12',45,'MySQL常见函数：\n定义：类似于java中学的\'方法\'，为了解决某个问题，将编写的一系列的命令集合封装在一起，对外仅仅暴露方法名，供外部调用\n1、自定义方法（函数）\n2、调用方法（函数）\nMySQL只需要知道函数名和函数功能\n①字符函数（专门用于处理字符型数据）\n②数学函数（专门用于处理数值型数据）\n③日期函数（专门用于处理日期型数值）\n④流程控制函数\n一、字符函数                             P272\nutf8：一个汉字占3个字节\nSUBSTRING 截取子串','2021-04-15 20:11:40',1),(76,'jdbc',47,'package com.kuang.lesson02.utils;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\npublic class JdbcUtils {\n   private static String driver = null;\n    private static String url = null;\n    private static String username = null;\n    private static String password = null;\n    static {\n       try {\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n            Properties properties = new Properties();\n            properties.load(in);\n            driver = properties.getProperty(\"driver\");\n            url = properties.getProperty(\"url\");\n            username = properties.getProperty(\"username\");\n            password = properties.getProperty(\"password\");\n            //驱动只用加载一次\n            Class.forName(driver);\n        } catch (Exception e) {\n            e.printStackTrace();            //捕获异常\n        }\n    }\n   //获取连接\n    public static Connection getConnection() throws SQLException{\n       return DriverManager.getConnection(url, username, password);\n    }\n   //释放连接资源\n    public static void release(Connection conn, Statement st, ResultSet rs){\n      if(rs!=null) {\n           try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n       }\n      if(st!=null) {\n           try {\n                st.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n       }\n      if(conn!=null) {\n           try {\n               conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n       }\n    }\n}','2021-04-15 20:13:35',1),(78,'jdbc01',48,'package com.kuang.lesson02;\nimport com.kuang.lesson02.utils.JdbcUtils;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\npublic class TestInsert {\n   public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            conn = JdbcUtils.getConnection();    //获取数据库连接\n            st = conn.createStatement();         //获得SQL的执行对象\n            String sql = \"INSERT INTO users(id,`NAME`,`PASSWORD`,`email`,`birthday`)\" +\n                   \"VALUES(4,\'kuangshen\',\'123456\',\'1421408389@qq.com\',\'2021-03-23\')\";\n            int i = st.executeUpdate(sql);\n            if(i>0){\n                System.out.println(\"插入成功\");\n            }\n        }catch(SQLException e){\n            e.printStackTrace();\n        }finally{\n            JdbcUtils.release(conn,st,rs);\n        }\n    }\n}','2021-04-15 20:14:43',1),(79,'jdbc02',49,'package com.kuang.lesson02;\nimport com.kuang.lesson02.utils.JdbcUtils;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\npublic class TestDelete {\n   public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            conn = JdbcUtils.getConnection();    //获取数据库连接\n            st = conn.createStatement();         //获得SQL的执行对象\n            String sql = \"DELETE FROM users WHERE id = 4 \";\n            int i = st.executeUpdate(sql);\n            if(i>0){\n                System.out.println(\"删除成功\");\n            }\n        }catch(SQLException e){\n            e.printStackTrace();\n        }finally{\n            JdbcUtils.release(conn,st,rs);\n        }\n    }\n}','2021-04-15 20:15:22',1),(81,'jdbc03',50,'package com.kuang.lesson02;\nimport com.kuang.lesson02.utils.JdbcUtils;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\npublic class TestSelect {\n   public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            conn = JdbcUtils.getConnection();    //获取数据库连接\n            st = conn.createStatement();         //获得SQL的执行对象\n            String sql = \"select * from users where id =1\" ;\n            rs = st.executeQuery(sql);        //查询：查询完毕会返回一个结果集\n            while(rs.next()){\n                System.out.println(rs.getString(\"NAME\"));\n            }\n        }catch(SQLException e){\n            e.printStackTrace();\n        }finally{\n            JdbcUtils.release(conn,st,rs);\n        }\n    }\n}','2021-04-15 20:18:39',1);

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `user_id` int NOT NULL AUTO_INCREMENT COMMENT '用户的唯一id',
  `user_name` varchar(60) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户昵称',
  `password` varchar(60) NOT NULL COMMENT '用户密码',
  `telephone` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户电话',
  `email` varchar(60) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户邮箱',
  `sign` varchar(200) DEFAULT NULL COMMENT '个性签名',
  `isblack` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否被拉黑',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `idx_unique_name` (`user_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`user_id`,`user_name`,`password`,`telephone`,`email`,`sign`,`isblack`) values (28,'路飞','202cb962ac59075b964b07152d234b70','17876971837','1421408389@qq.com','我是要成为海贼王的男人',1),(29,'索隆','202cb962ac59075b964b07152d234b70','17876971831','1421408381@qq.com','成为世界第一剑豪',1),(31,'lwx','250cf8b51c773f3f8dc8b4be867a9a02','17876971832','1421408382@qq.com','狂风之力',1),(32,'Curry','68053af2923e00204c3ca7c6a3150cf7','17876971833','1421408383','three！',1),(33,'djy','e10adc3949ba59abbe56e057f20f883e','17876971836','1421408386@qq.com','6',1),(34,'djy1','202cb962ac59075b964b07152d234b70','17876971839','1421408388@qq.com','djy1',1),(35,'djy2','202cb962ac59075b964b07152d234b70','2','2','2',1),(36,'djy3','eccbc87e4b5ce2fe28308fd9f2a7baf3','3','3','3',1),(37,'djy4','a87ff679a2f3e71d9181a67b7542122c','4','4','4',1),(38,'djy5','e4da3b7fbbce2345d7772b0674a318d5','5','5','5',1),(39,'djy6','1679091c5a880faf6fb5e6087eb1b2dc','6','6','6',1),(40,'djy7','8f14e45fceea167a5a36dedd4bea2543','7','7','7',1),(41,'djy8','c9f0f895fb98ab9159f51fd0297e236d','8','8','8',1),(42,'djy9','45c48cce2e2d7fbdea1afc51c7c6ad26','9','9','9',1),(43,'djy10','d3d9446802a44259755d38e6d163e820','10','10','10',1),(44,'sql11','6512bd43d9caa6e02c990b0a82652dca','11','11','11',0),(45,'djy12','c20ad4d76fe97759aa27a0c99bff6710','12','12','12',1),(47,'djy13','c51ce410c124a10e0db5e4b97fc2af39','13','13','13',1),(48,'djy15','9bf31c7ff062936a96d3c8bd1f8f2ff3','15','15','15',1),(49,'djy16','c74d97b01eae257e44aa9d5bade97baf','16','16','16',1),(50,'djy17','70efdf2ec9b086079795c442636b55fb','17','17','17',1);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
